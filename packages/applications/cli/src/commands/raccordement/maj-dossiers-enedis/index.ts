import path from 'path';

import { PDFDocument, StandardFonts } from 'pdf-lib';
import { mediator } from 'mediateur';
import { Command, Flags } from '@oclif/core';
import zod from 'zod';

import { Option } from '@potentiel-libraries/monads';
import {
  countProjection,
  findProjection,
  listProjection,
} from '@potentiel-infrastructure/pg-projection-read';
import { r√©cup√©rerIdentifiantsProjetParEmailPorteurAdapter } from '@potentiel-infrastructure/domain-adapters';
import { killPool } from '@potentiel-libraries/pg-helpers';
import { getLogger } from '@potentiel-libraries/monitoring';
import { Raccordement, registerLaur√©atQueries } from '@potentiel-domain/laureat';
import { DateTime, Email } from '@potentiel-domain/common';
import { ConsulterDocumentProjetQuery } from '@potentiel-domain/document';

import { parseCsvFile } from '../../../helpers/parse-file';

const envVariablesSchema = zod.object({
  // s3
  S3_BUCKET: zod.string({ message: 'S3_BUCKET is required' }),
  S3_ENDPOINT: zod.string({ message: 'S3_ENDPOINT is required' }),
  AWS_REGION: zod.string({ message: 'AWS_REGION is required' }),
  AWS_ACCESS_KEY_ID: zod.string({ message: 'AWS_ACCESS_KEY_ID is required' }),
  AWS_SECRET_ACCESS_KEY: zod.string({ message: 'AWS_SECRET_ACCESS_KEY is required' }),
  // Database
  DATABASE_CONNECTION_STRING: zod.string({ message: 'DATABASE_CONNECTION_STRING is required' }),
});

type Statistics = {
  total: number;
  ligneSansR√©f√©renceDossier: Array<string>;
  projetSansRaccordement: Array<string>;
  plusieursDossiersDeRaccordement: Array<{
    identifiantProjet: string;
    r√©f√©renceFichier: string;
    r√©f√©rencesActuelles: string[];
  }>;
  UnSeulDossierDeRaccordement: {
    total: number;
    modifierR√©f√©renceDossierRaccordement: {
      total: number;
      succ√®s: Array<{
        identifiantProjet: string;
        r√©f√©renceDossier: string;
      }>;
      erreurs: Array<{
        identifiantProjet: string;
        r√©f√©renceDossier: string;
        erreur: string;
      }>;
    };
    modifierDemandeCompl√®tementRaccordement: {
      total: number;
      succ√®s: Array<{
        identifiantProjet: string;
        dateQualification: string;
      }>;
      erreurs: Array<{
        identifiantProjet: string;
        dateQualification: string;
        erreur: string;
      }>;
    };
    transmettreDateMiseEnService: {
      total: number;
      succ√®s: Array<{
        identifiantProjet: string;
        dateMiseEnService: string;
      }>;
      erreurs: Array<{
        identifiantProjet: string;
        dateMiseEnService: string;
        erreur: string;
      }>;
    };
  };
  pasDeDossierDeRaccordement: {
    total: number;
    transmettreDemandeCompl√®tementRaccordement: {
      total: number;
      succ√®s: Array<{
        identifiantProjet: string;
        r√©f√©renceDossier: string;
      }>;
      erreurs: Array<{
        identifiantProjet: string;
        r√©f√©renceDossier: string;
        erreur: string;
      }>;
    };
    transmettreDateMiseEnService: {
      total: number;
      succ√®s: Array<{
        identifiantProjet: string;
        dateMiseEnService: string;
      }>;
      erreurs: Array<{
        identifiantProjet: string;
        dateMiseEnService: string;
        erreur: string;
      }>;
    };
  };
};

export class MajDossiersEnedis extends Command {
  static description =
    "Lire le contenu d'un fichier CSV rempli par Enedis pour venir (en one shot) cr√©er / mettre √† jour les dossiers de raccordement ainsi que la date de mise en service. Cette op√©ration est ponctuelle";

  async init() {
    registerLaur√©atQueries({
      count: countProjection,
      find: findProjection,
      list: listProjection,
      r√©cup√©rerIdentifiantsProjetParEmailPorteur: r√©cup√©rerIdentifiantsProjetParEmailPorteurAdapter,
    });
  }

  static flags = {
    dryRun: Flags.boolean(),
  };

  async finally() {
    await killPool();
  }

  async run() {
    envVariablesSchema.parse(process.env);

    const { flags } = await this.parse(MajDossiersEnedis);
    const logger = getLogger(MajDossiersEnedis.name);

    logger.info('üèÅ D√©but de la mise √† jour des dossiers de raccordement');

    const csvSchema = zod.object({
      appelOffre: zod.string(),
      periode: zod.string(),
      famille: zod.string().optional(),
      numeroCRE: zod.string(),
      referenceDossier: zod.string().optional(),
      dateAccuseReception: zod.string().optional(),
      dateMiseEnService: zod.string().optional(),
    });

    const { parsedData } = await parseCsvFile(
      path.resolve(__dirname, './dossiers_raccordements_modifies_fake.csv'),
      csvSchema,
      {
        delimiter: ',',
        encoding: 'utf8',
      },
    );

    if (parsedData.length === 0) {
      logger.error('‚ùå Aucune donn√©e √† traiter ‚ùå');
      process.exit(1);
    }

    const statistics: Statistics = {
      total: parsedData.length,
      ligneSansR√©f√©renceDossier: [],
      projetSansRaccordement: [],
      plusieursDossiersDeRaccordement: [],
      UnSeulDossierDeRaccordement: {
        total: 0,
        modifierR√©f√©renceDossierRaccordement: {
          total: 0,
          succ√®s: [],
          erreurs: [],
        },
        modifierDemandeCompl√®tementRaccordement: {
          total: 0,
          succ√®s: [],
          erreurs: [],
        },
        transmettreDateMiseEnService: {
          total: 0,
          succ√®s: [],
          erreurs: [],
        },
      },
      pasDeDossierDeRaccordement: {
        total: 0,
        transmettreDemandeCompl√®tementRaccordement: {
          total: 0,
          succ√®s: [],
          erreurs: [],
        },
        transmettreDateMiseEnService: {
          total: 0,
          succ√®s: [],
          erreurs: [],
        },
      },
    };

    let index = 1;

    for (const ligne of parsedData) {
      const identifiantProjet = `${ligne.appelOffre}#${ligne.periode}#${ligne.famille}#${ligne.numeroCRE}`;

      console.log(`Traitement du projet ${identifiantProjet} (${index} / ${parsedData.length})`);

      /**
       * Pas de r√©f√©rence de dossier renseign√©e
       */
      if (!ligne.referenceDossier) {
        statistics.ligneSansR√©f√©renceDossier.push(identifiantProjet);
        index++;
        continue;
      }

      const raccordement = await mediator.send<Raccordement.ConsulterRaccordementQuery>({
        type: 'Laur√©at.Raccordement.Query.ConsulterRaccordement',
        data: {
          identifiantProjetValue: identifiantProjet,
        },
      });

      /**
       * Raccordement inexistant
       */
      if (Option.isNone(raccordement)) {
        statistics.projetSansRaccordement.push(identifiantProjet);
        index++;
        continue;
      }

      /**
       * Si plusieurs dossiers rattach√©s au raccordement du projet, on ne peut pas savoir duquel on parle ??
       */
      if (raccordement.dossiers.length > 1) {
        statistics.plusieursDossiersDeRaccordement.push({
          identifiantProjet,
          r√©f√©renceFichier: ligne.referenceDossier,
          r√©f√©rencesActuelles: raccordement.dossiers.map((dossier) =>
            dossier.r√©f√©rence.formatter(),
          ),
        });
        index++;
        continue;
      }

      /**
       * Si il y a un dossier de raccordement
       */
      if (raccordement.dossiers.length === 1) {
        statistics.UnSeulDossierDeRaccordement.total++;

        const dossierRaccordement = raccordement.dossiers[0];

        /**
         * Si la r√©f√©rence du dossier de raccordement actuelle est "R√©f√©rence non transmise"
         */
        if (
          dossierRaccordement.r√©f√©rence.est√âgale√Ä(
            Raccordement.R√©f√©renceDossierRaccordement.r√©f√©renceNonTransmise,
          )
        ) {
          try {
            if (!flags.dryRun) {
              await mediator.send<Raccordement.ModifierR√©f√©renceDossierRaccordementUseCase>({
                type: 'Laur√©at.Raccordement.UseCase.ModifierR√©f√©renceDossierRaccordement',
                data: {
                  identifiantProjetValue: identifiantProjet,
                  r√©f√©renceDossierRaccordementActuelleValue:
                    dossierRaccordement.r√©f√©rence.formatter(),
                  nouvelleR√©f√©renceDossierRaccordementValue: ligne.referenceDossier,
                  r√¥leValue: 'admin',
                  modifi√©eLeValue: DateTime.now().formatter(),
                  modifi√©eParValue: Email.system().formatter(),
                },
              });
            }
            statistics.UnSeulDossierDeRaccordement.modifierR√©f√©renceDossierRaccordement.total++;
            statistics.UnSeulDossierDeRaccordement.modifierR√©f√©renceDossierRaccordement.succ√®s.push(
              {
                identifiantProjet,
                r√©f√©renceDossier: ligne.referenceDossier,
              },
            );
          } catch (error) {
            statistics.UnSeulDossierDeRaccordement.modifierR√©f√©renceDossierRaccordement.total++;
            statistics.UnSeulDossierDeRaccordement.modifierR√©f√©renceDossierRaccordement.erreurs.push(
              {
                identifiantProjet,
                r√©f√©renceDossier: ligne.referenceDossier,
                erreur: error as string,
              },
            );
            index++;
            continue;
          }
        }

        /*
         * Si il y a une date de qualification et qu'elle est diff√©rente de l'existant
         */
        if (
          ligne.dateAccuseReception &&
          dossierRaccordement.demandeCompl√®teRaccordement.dateQualification &&
          !dossierRaccordement.demandeCompl√®teRaccordement.dateQualification.est√âgale√Ä(
            DateTime.convertirEnValueType(formatDateQualification(ligne.dateAccuseReception)),
          )
        ) {
          try {
            if (!flags.dryRun) {
              /**
               * Par d√©faut, on g√©n√®re un accus√© de r√©ception
               */
              let accus√©R√©ceptionValue = await generateDocument(
                `Accus√© de r√©ception de la demande compl√®te de raccordement pour le dossier ${ligne.referenceDossier} du projet ${identifiantProjet}`,
              );

              /**
               * Si l'accus√© de r√©ception est d√©j√† pr√©sent, on le r√©cup√®re
               */
              if (dossierRaccordement.demandeCompl√®teRaccordement.accus√©R√©ception) {
                const document = await mediator.send<ConsulterDocumentProjetQuery>({
                  type: 'Document.Query.ConsulterDocumentProjet',
                  data: {
                    documentKey:
                      dossierRaccordement.demandeCompl√®teRaccordement.accus√©R√©ception.formatter(),
                  },
                });

                if (Option.isSome(document)) {
                  accus√©R√©ceptionValue = document;
                }
              }

              await mediator.send<Raccordement.ModifierDemandeCompl√®teRaccordementUseCase>({
                type: 'Laur√©at.Raccordement.UseCase.ModifierDemandeCompl√®teRaccordement',
                data: {
                  identifiantProjetValue: identifiantProjet,
                  r√©f√©renceDossierRaccordementValue: ligne.referenceDossier,
                  dateQualificationValue: formatDateQualification(ligne.dateAccuseReception),
                  accus√©R√©ceptionValue,
                  r√¥leValue: 'admin',
                },
              });
            }

            statistics.UnSeulDossierDeRaccordement.modifierDemandeCompl√®tementRaccordement.total++;
            statistics.UnSeulDossierDeRaccordement.modifierDemandeCompl√®tementRaccordement.succ√®s.push(
              {
                identifiantProjet,
                dateQualification: ligne.dateAccuseReception,
              },
            );
          } catch (error) {
            statistics.UnSeulDossierDeRaccordement.modifierDemandeCompl√®tementRaccordement.total++;
            statistics.UnSeulDossierDeRaccordement.modifierDemandeCompl√®tementRaccordement.erreurs.push(
              {
                identifiantProjet,
                dateQualification: ligne.dateAccuseReception,
                erreur: error as string,
              },
            );
            index++;
            continue;
          }
        }

        /***
         * Si il y a une date de mise en service et qu'elle est diff√©rente de l'existant
         */
        if (
          ligne.dateMiseEnService &&
          dossierRaccordement.miseEnService?.dateMiseEnService &&
          !dossierRaccordement.miseEnService.dateMiseEnService.est√âgale√Ä(
            DateTime.convertirEnValueType(formatDateQualification(ligne.dateMiseEnService)),
          )
        ) {
          try {
            if (!flags.dryRun) {
              await mediator.send<Raccordement.TransmettreDateMiseEnServiceUseCase>({
                type: 'Laur√©at.Raccordement.UseCase.TransmettreDateMiseEnService',
                data: {
                  identifiantProjetValue: identifiantProjet,
                  r√©f√©renceDossierValue: ligne.referenceDossier,
                  dateMiseEnServiceValue: formatDateQualification(ligne.dateMiseEnService),
                  transmiseLeValue: DateTime.now().formatter(),
                  transmiseParValue: Email.system().formatter(),
                },
              });
            }
            statistics.UnSeulDossierDeRaccordement.transmettreDateMiseEnService.total++;
            statistics.UnSeulDossierDeRaccordement.transmettreDateMiseEnService.succ√®s.push({
              identifiantProjet,
              dateMiseEnService: ligne.dateMiseEnService,
            });
          } catch (error) {
            statistics.UnSeulDossierDeRaccordement.transmettreDateMiseEnService.total++;
            statistics.UnSeulDossierDeRaccordement.transmettreDateMiseEnService.erreurs.push({
              identifiantProjet,
              dateMiseEnService: ligne.dateMiseEnService,
              erreur: error as string,
            });
            index++;
            continue;
          }
        }
      }

      if (raccordement.dossiers.length === 0) {
        statistics.pasDeDossierDeRaccordement.total++;

        if (!ligne.dateAccuseReception) {
          statistics.pasDeDossierDeRaccordement.transmettreDemandeCompl√®tementRaccordement.erreurs.push(
            {
              identifiantProjet,
              r√©f√©renceDossier: ligne.referenceDossier,
              erreur: "Pas de ligne date d'accus√© de r√©ception",
            },
          );
          index++;
          continue;
        }

        try {
          if (!flags.dryRun) {
            const accus√©R√©ceptionValue = await generateDocument(
              `Accus√© de r√©ception de la demande compl√®te de raccordement non transmis pour le dossier ${ligne.referenceDossier} du projet ${identifiantProjet}`,
            );

            await mediator.send<Raccordement.TransmettreDemandeCompl√®teRaccordementUseCase>({
              type: 'Laur√©at.Raccordement.UseCase.TransmettreDemandeCompl√®teRaccordement',
              data: {
                identifiantProjetValue: identifiantProjet,
                dateQualificationValue: ligne.dateAccuseReception,
                accus√©R√©ceptionValue,
                r√©f√©renceDossierValue: ligne.referenceDossier,
              },
            });
          }

          statistics.pasDeDossierDeRaccordement.transmettreDemandeCompl√®tementRaccordement.total++;
          statistics.pasDeDossierDeRaccordement.transmettreDemandeCompl√®tementRaccordement.succ√®s.push(
            {
              identifiantProjet,
              r√©f√©renceDossier: ligne.referenceDossier,
            },
          );
        } catch (error) {
          statistics.pasDeDossierDeRaccordement.transmettreDemandeCompl√®tementRaccordement.total++;
          statistics.pasDeDossierDeRaccordement.transmettreDemandeCompl√®tementRaccordement.erreurs.push(
            {
              identifiantProjet,
              r√©f√©renceDossier: ligne.referenceDossier,
              erreur: error as string,
            },
          );
          index++;
          continue;
        }

        if (ligne.dateMiseEnService) {
          try {
            if (!flags.dryRun) {
              const dateMiseEnServiceValue = formatDateQualification(ligne.dateMiseEnService);

              await mediator.send<Raccordement.TransmettreDateMiseEnServiceUseCase>({
                type: 'Laur√©at.Raccordement.UseCase.TransmettreDateMiseEnService',
                data: {
                  identifiantProjetValue: identifiantProjet,
                  r√©f√©renceDossierValue: ligne.referenceDossier,
                  dateMiseEnServiceValue,
                  transmiseLeValue: DateTime.now().formatter(),
                  transmiseParValue: Email.system().formatter(),
                },
              });
              statistics.pasDeDossierDeRaccordement.transmettreDateMiseEnService.total++;
              statistics.pasDeDossierDeRaccordement.transmettreDateMiseEnService.succ√®s.push({
                identifiantProjet,
                dateMiseEnService: ligne.dateMiseEnService,
              });
            }
          } catch (error) {
            statistics.pasDeDossierDeRaccordement.transmettreDateMiseEnService.total++;
            statistics.pasDeDossierDeRaccordement.transmettreDateMiseEnService.erreurs.push({
              identifiantProjet,
              dateMiseEnService: ligne.dateMiseEnService,
              erreur: error as string,
            });
            index++;
            continue;
          }
        }
      }
    }

    /*
 const statistics: Statistics = {
   total: parsedData.length,
   ligneSansR√©f√©renceDossier: [],
   projetSansRaccordement: [],
   plusieursDossiersDeRaccordement: [],
   UnSeulDossierDeRaccordement: {
     total: 0,
     modifierR√©f√©renceDossierRaccordement: {
       total: 0,
       succ√®s: [],
       erreurs: [],
     },
     modifierDemandeCompl√®tementRaccordement: {
       total: 0,
       succ√®s: [],
       erreurs: [],
     },
     transmettreDateMiseEnService: {
       total: 0,
       succ√®s: [],
       erreurs: [],
     },
   },
   pasDeDossierDeRaccordement: {
     total: 0,
     transmettreDemandeCompl√®tementRaccordement: {
       total: 0,
       succ√®s: [],
       erreurs: [],
     },
     transmettreDateMiseEnService: {
       total: 0,
       succ√®s: [],
       erreurs: [],
     },
   },
 };

*/

    logger.info('üìä Statistiques de la mise √† jour des dossiers de raccordement :');
    logger.info(`Total : ${statistics.total} / ${parsedData.length}`);
    logger.info(`Ligne sans r√©f√©rence de dossier : ${statistics.ligneSansR√©f√©renceDossier.length}`);
    logger.info(`Projet sans raccordement : ${statistics.projetSansRaccordement.length}`);
    logger.info(
      `Plusieurs dossiers de raccordement : ${statistics.plusieursDossiersDeRaccordement.length}`,
    );
    logger.info(
      `Un seul dossier de raccordement : ${statistics.UnSeulDossierDeRaccordement.total}`,
    );
    logger.info(`Pas de dossier de raccordement : ${statistics.pasDeDossierDeRaccordement.total}`);

    process.exit(0);
  }
}

const generateDocument = async (text: string) => {
  const pdfDoc = await PDFDocument.create();
  const page = pdfDoc.addPage();

  const textSize = 24;

  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const textWidth = helveticaFont.widthOfTextAtSize(text, textSize);
  const textHeight = helveticaFont.heightAtSize(textSize);

  const x = page.getWidth() / 2 - textWidth / 2;

  page.drawText(text, {
    x: x > 0 ? x : 0,
    y: page.getHeight() / 2 - textHeight / 2,
    size: textSize,
    font: helveticaFont,
    maxWidth: page.getWidth(),
  });

  const pdfBytes = await pdfDoc.save();

  return {
    format: 'application/pdf',
    content: new Blob([pdfBytes], { type: 'application/pdf' }).stream(),
  };
};

const formatDateQualification = (dateString: string) => {
  return new Date(dateString.replace(/(\d{2})\/(\d{2})\/(\d{4})/, '$3-$2-$1')).toISOString();
};
